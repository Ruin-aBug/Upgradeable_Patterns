# Upgradeable Contracts and Patterns
我们知道以太坊上的智能合约是不可升级的，因为代码是不可变的，一旦部署就无法更改。但是第一次写出完美的代码是很困难的，作为人类，我们都容易犯错误。有时，即使是经过审计的合同也会出现让他们损失数百万美元的漏洞。

## 工作原理
使用代理模式（`Proxy Patten`）进行合约的升级。

本质上讲，代理模式是将合约分为两个合约-代理合约（`Proxy Contract`）和实现合约（`Implementation Contract`）。

代理合约负责管理涉及持久存储的合约状态，而实现合约负责执行逻辑并且不存储任何持久状态。用户通过调用代理合约，代理合约进一步对实现合约执行`delegatecall`，这样它就可以实现逻辑。
![代理原理](https://i.imgur.com/NpGQqsL.png)

## 升级方式
目前主要有三种方式进行实现合约升级/替换
- Diamond  (钻石代理)
- Transparent  (透明代理)
- UUPS (UUPS 代理)

最常用的是透明代理和UUPS代理。

## 实现方式
透明代理和UUPS代理主要区别在于把upgradeTo(address)方法放在哪里，把它放在`Proxy Contract`中，这基本是透明代理的实现方式，把它放在实现合约中，这就是UUPS代理的实现方式。

>注意：关于代理模式，另一个需要注意的是，实现合约的构造函数永远不会被执行。

在部署新的智能合约时，构造函数中的代码不是合约运行时字节码的一部分，因为它只在部署阶段需要并且只运行一次。因为在部署实现合约时，它的构造函数没有连接到代理合约中，所以它构造函数里面的状态改变不会被执行，最终也不会保存状态到代理合约上。

代理合约不知道构造函数的存在，因此，我们不要使用构造函数，而是使用`initializer`函数，代理合约一旦与实现合约连接，这个方法就会被调用。这个函数的作用与构造函数完全相同，但是它是包含着运行时的字节码中的，因为它跟普通方法的定义一样，所以可以被代理合约调用。

使用 `OpenZeppelin` 合约，您可以使用他们的[`Initialize.sol`](https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies#the-constructor-caveat)合约来确保您的`initialize`函数像构造函数一样只执行一次。

## 透明代理模式（Transparent Proxy Pattern）
透明代理模式是一种简单的方法来分离代理合约和实现合约之间的责任。在这种情况下，upgradeTo函数是代理合约的一部分，而实现可以通过在代理上调用upgradeTo来升级，从而改变未来函数调用的委托位置。

不过也有一些注意事项。可能有这样一种情况：代理合约和实施合约有一个名称和参数相同的函数。例如，如果代理合同有一个`owner()`函数，实施合约也有。在透明代理合约中，这个问题由代理合约来处理，代理合约根据msg.sender全局变量来决定用户的调用是在代理合约本身还是在实现合约中执行。

因此，如果`msg.sender`是代理的管理员，那么代理将不会委托调用，并且会在它理解的情况下尝试执行调用。如果它不是管理员地址，即使匹配是代理的功能之一，代理也会将调用委托给实现合约。

### 透明代理的问题
我们知道，`owner`的地址必须存储在存储器中，而使用存储器是与智能合约互动的最低效和最昂贵的步骤之一，每次用户调用代理时，代理会检查用户是否是管理员，这给大多数发生的交易增加了不必要的气体成本。

## UUPS代理模式
UUPS代理模式是另一种在代理合同和实现合同之间分离责任的方式。在这种情况下，upgradeTo函数也是实现合约的一部分，并且通过代理被所有者使用`delegatecall`。

在UUPS中，不管是管理员还是用户，所有的调用都被发送到实现合约中。这样做的好处是，每次调用时，我们不必访问存储空间来检查开始调用的用户是否是管理员，这提高了效率和成本。同时，因为它是实现合约，你可以根据你的需要定制功能，在每一个新的实现中加入诸如时间锁、访问控制等，这在透明代理模式中是做不到的。

### UUPS代理的问题
现在的问题是，因为upgradeTo函数存在于实施合约中，开发者不得不担心这个函数的实现，这有时可能很复杂，而且因为增加了更多的代码，这增加了攻击的可能性。这个函数也需要在所有被升级的实施合约的版本中出现，这就引入了一个风险，如果开发者忘记添加这个函数，那么合约就不能再被升级了。


Learning content from learnWeb3
